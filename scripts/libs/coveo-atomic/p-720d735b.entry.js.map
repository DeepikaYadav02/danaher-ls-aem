{"version":3,"names":["AtomicResultText","this","shouldHighlight","renderWithHighlights","value","highlights","openingDelimiter","closingDelimiter","highlightedValue","HighlightUtils","highlightString","content","innerHTML","replace","RegExp","h","Host","error","possiblyWarnOnBadFieldType","resultValueRaw","ResultTemplatesHelpers","getResultProperty","result","field","isArray","bindings","engine","logger","render","resultValueAsString","getStringValueFromResultOrNull","default","host","remove","getFieldValueCaption","i18n","textValue","highlightsValue","__decorate","InitializeBindings","ResultContext"],"sources":["src/components/search/result-template-components/atomic-result-text/atomic-result-text.tsx"],"sourcesContent":["import {isArray} from '@coveo/bueno';\nimport {HighlightUtils, Result, ResultTemplatesHelpers} from '@coveo/headless';\nimport {Component, Prop, h, Element, Host, State} from '@stencil/core';\nimport {getFieldValueCaption} from '../../../../utils/field-utils';\nimport {\n  InitializableComponent,\n  InitializeBindings,\n} from '../../../../utils/initialization-utils';\nimport {getStringValueFromResultOrNull} from '../../../../utils/result-utils';\nimport {Bindings} from '../../atomic-search-interface/atomic-search-interface';\nimport {ResultContext} from '../result-template-decorators';\n\n/**\n * The `atomic-result-text` component renders the value of a string result field.\n */\n@Component({\n  tag: 'atomic-result-text',\n  shadow: false,\n})\nexport class AtomicResultText implements InitializableComponent {\n  @InitializeBindings() public bindings!: Bindings;\n  @ResultContext() private result!: Result;\n\n  @Element() private host!: HTMLElement;\n\n  @State() public error!: Error;\n\n  /**\n   * The result field which the component should use.\n   * This will look in the Result object first, and then in the Result.raw object for the fields.\n   * It is important to include the necessary field in the `atomic-search-interface` component.\n   */\n  @Prop({reflect: true}) public field!: string;\n  /**\n   * If this is set to true, it will look for the corresponding highlight property and use it if available.\n   */\n  @Prop({reflect: true}) public shouldHighlight = true;\n\n  /**\n   * The locale key for the text to display when the configured field has no value.\n   */\n  @Prop({reflect: true}) public default?: string;\n\n  private renderWithHighlights(\n    value: string,\n    highlights: HighlightUtils.HighlightKeyword[]\n  ) {\n    try {\n      const openingDelimiter = '_openingDelimiter_';\n      const closingDelimiter = '_closingDelimiter_';\n      const highlightedValue = HighlightUtils.highlightString({\n        content: value,\n        openingDelimiter,\n        closingDelimiter,\n        highlights,\n      });\n      const innerHTML = highlightedValue\n        .replace(new RegExp(openingDelimiter, 'g'), '<b>')\n        .replace(new RegExp(closingDelimiter, 'g'), '</b>');\n      // deepcode ignore ReactSetInnerHtml: This is not React code\n      return <Host innerHTML={innerHTML}></Host>;\n    } catch (error) {\n      this.error = error as Error;\n    }\n  }\n\n  private possiblyWarnOnBadFieldType() {\n    const resultValueRaw = ResultTemplatesHelpers.getResultProperty(\n      this.result,\n      this.field\n    );\n    if (isArray(resultValueRaw)) {\n      this.bindings.engine.logger.error(\n        `atomic-result-text cannot be used with multi value field \"${this.field}\" with values \"${resultValueRaw}\". Use atomic-result-multi-value-text instead.`,\n        this\n      );\n    }\n  }\n\n  public render() {\n    const resultValueAsString = getStringValueFromResultOrNull(\n      this.result,\n      this.field\n    );\n    if (!resultValueAsString && !this.default) {\n      this.possiblyWarnOnBadFieldType();\n      this.host.remove();\n      return;\n    }\n\n    if (!resultValueAsString && this.default) {\n      this.possiblyWarnOnBadFieldType();\n      return (\n        <atomic-text\n          value={getFieldValueCaption(\n            this.field,\n            this.default,\n            this.bindings.i18n\n          )}\n        ></atomic-text>\n      );\n    }\n\n    const textValue = `${resultValueAsString}`;\n    const highlightsValue = ResultTemplatesHelpers.getResultProperty(\n      this.result,\n      `${this.field}Highlights`\n    ) as HighlightUtils.HighlightKeyword[];\n\n    if (this.shouldHighlight && highlightsValue) {\n      return this.renderWithHighlights(textValue, highlightsValue);\n    }\n\n    return getFieldValueCaption(this.field, textValue, this.bindings.i18n);\n  }\n}\n"],"mappings":"itBAmBaA,EAAgB,M,yBAiBGC,KAAAC,gBAAkB,K,+DAAA,K,uBAOxC,oBAAAC,CACNC,EACAC,GAEA,IACE,MAAMC,EAAmB,qBACzB,MAAMC,EAAmB,qBACzB,MAAMC,EAAmBC,EAAeC,gBAAgB,CACtDC,QAASP,EACTE,mBACAC,mBACAF,eAEF,MAAMO,EAAYJ,EACfK,QAAQ,IAAIC,OAAOR,EAAkB,KAAM,OAC3CO,QAAQ,IAAIC,OAAOP,EAAkB,KAAM,QAE9C,OAAOQ,EAACC,EAAI,CAACJ,UAAWA,G,CACxB,MAAOK,GACPhB,KAAKgB,MAAQA,C,EAIT,0BAAAC,GACN,MAAMC,EAAiBC,EAAuBC,kBAC5CpB,KAAKqB,OACLrB,KAAKsB,OAEP,GAAIC,EAAQL,GAAiB,CAC3BlB,KAAKwB,SAASC,OAAOC,OAAOV,MAC1B,6DAA6DhB,KAAKsB,uBAAuBJ,kDACzFlB,K,EAKC,MAAA2B,GACL,MAAMC,EAAsBC,EAC1B7B,KAAKqB,OACLrB,KAAKsB,OAEP,IAAKM,IAAwB5B,KAAK8B,QAAS,CACzC9B,KAAKiB,6BACLjB,KAAK+B,KAAKC,SACV,M,CAGF,IAAKJ,GAAuB5B,KAAK8B,QAAS,CACxC9B,KAAKiB,6BACL,OACEH,EAAA,eACEX,MAAO8B,EACLjC,KAAKsB,MACLtB,KAAK8B,QACL9B,KAAKwB,SAASU,O,CAMtB,MAAMC,EAAY,GAAGP,IACrB,MAAMQ,EAAkBjB,EAAuBC,kBAC7CpB,KAAKqB,OACL,GAAGrB,KAAKsB,mBAGV,GAAItB,KAAKC,iBAAmBmC,EAAiB,CAC3C,OAAOpC,KAAKE,qBAAqBiC,EAAWC,E,CAG9C,OAAOH,EAAqBjC,KAAKsB,MAAOa,EAAWnC,KAAKwB,SAASU,K,6BA7FtCG,EAAA,CAA5BC,K,+BACwBD,EAAA,CAAxBE,K"}